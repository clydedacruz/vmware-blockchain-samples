    # Global tags can be specified here in key="value" format.
    [global_tags]
      blockchain = "746d220e-1eb9-4d15-ae1b-a224cee8d396"
      #source = "746d220e-1eb9-4d15-ae1b-a224cee8d396"

    # Configuration for telegraf agent
    [agent]
      interval = "10s"
      round_interval = true

      metric_batch_size = 1000

      metric_buffer_limit = 10000

      collection_jitter = "0s"

      flush_interval = "10s"
      flush_jitter = "0s"

      precision = ""

     ## Override default hostname, if empty use os.Hostname()
       hostname = ""
       omit_hostname = true

    # # Configuration for Wavefront server to send metrics to
    #[[outputs.wavefront]]
    #   host = "wavefront-proxy"
    #   port = 2878
    #   prefix = "vmware.blockchain."

    # Telegraf pull metrics configuration
    [[outputs.prometheus_client]]
       ## Address to listen on
       listen = ":9273"

    #   ## Use HTTP Basic Authentication.
    #   basic_username = "$TELEGRAF_USERNAME"
    #   basic_password = "$TELEGRAF_PASSWORD"

       ## Path to publish the metrics on.
       path = "/metrics"

    #   ## enable TLS with the given certificate if provided by users
    #   $ENABLE_TELEGRAF_TLS tls_cert = "/config/telegraf/certs/prometheus_client/telegraf.crt"
    #   $ENABLE_TELEGRAF_TLS tls_key = "/config/telegraf/certs/prometheus_client/telegraf.key"

    # Telegraf push metrics configuration
    # [[outputs.http]]

    #  ## Use HTTP Basic Authentication.
    #   url = "$PUSH_METRICS_HTTP_URL"
    #   $ENABLE_PUSH_METRICS_HTTP_USERNAME username = "$PUSH_METRICS_HTTP_USERNAME"
    #   $ENABLE_PUSH_METRICS_HTTP_PASSWORD password = "$PUSH_METRICS_HTTP_PASSWORD"

    #   ## enable TLS with the given certificate if provided by users
    #   $ENABLE_PUSH_METRICS_HTTP_TLS tls_cert = "/config/telegraf/certs/push_metrics_http/telegraf.crt"
    #   insecure_skip_verify = true

    ## Additional HTTP headers
        # [outputs.http.headers]
        #    Content-Type = "application/json"
        #  $ENABLE_PUSH_METRICS_HTTP_TOKEN  Authorization = "$PUSH_METRICS_HTTP_TOKEN"


    [[outputs.cloudwatch]]
       region = "us-west-1"
       namespace = "vmbc-samples"
      ## Amazon Credentials
      ## Credentials are loaded in the following order
      ## 1) Web identity provider credentials via STS if role_arn and web_identity_token_file are specified
      ## 2) Assumed credentials via STS if role_arn is specified
      ## 3) explicit credentials from 'access_key' and 'secret_key'
      ## 4) shared profile from 'profile'
      ## 5) environment variables
      ## 6) shared credentials file
      ## 7) EC2 Instance Profile
          access_key = "$CW_ACCESS_KEY"
          secret_key = "$CW_SECRET_KEY"
          token = "$CW_TOKEN_KEY"


    #[[outputs.azure_monitor]]
    #   namespace_prefix = "vmwblockchain/"

    # Read metrics about cpu usage
    [[inputs.cpu]]
      percpu = true
      totalcpu = true
      collect_cpu_time = false
      report_active = false

    # Read metrics about disk usage by mount point
    [[inputs.disk]]
      ## Ignore mount points by filesystem type.
      ignore_fs = ["tmpfs", "devtmpfs", "devfs", "iso9660", "overlay", "aufs", "squashfs"]

    [[inputs.docker]]
      ## Docker Endpoint
      ##   To use TCP, set endpoint = "tcp://[ip]:[port]"
      ##   To use environment variables (ie, docker-machine), set endpoint = "ENV"
      endpoint = "unix:///var/run/docker.sock"

      ## Set to true to collect Swarm metrics(desired_replicas, running_replicas)
      gather_services = false

      ## Only collect metrics for these containers, collect all if empty
      container_names = []

      ## Containers to include and exclude. Globs accepted.
      ## Note that an empty array for both will include all containers
      container_name_include = []
      container_name_exclude = []

      ## Container states to include and exclude. Globs accepted.
      ## When empty only containers in the "running" state will be captured.
      container_state_include = ["created", "restarting", "running", "removing", "paused", "exited", "dead"]
      # container_state_exclude = []

      ## Timeout for docker list, info, and stats commands
      timeout = "5s"

      ## Whether to report for each container per-device blkio (8:0, 8:1...) and
      ## network (eth0, eth1, ...) stats or not
      perdevice = true
      ## Whether to report for each container total blkio and network stats or not
      total = false

      ## docker labels to include and exclude as tags.  Globs accepted.
      ## Note that an empty array for both will include all labels as tags
      docker_label_include = []
      docker_label_exclude = []

    [[inputs.diskio]]

    [[inputs.kernel]]

    [[inputs.mem]]

    [[inputs.processes]]

    [[inputs.swap]]

    [[inputs.system]]

    [[inputs.net]]

    [[inputs.net_response]]
      ## Protocol, must be "tcp" or "udp"
      ## NOTE: because the "udp" protocol does not respond to requests, it requires
      ## a send/expect string pair (see below).
      protocol = "tcp"
      ## Server address (default localhost)
      address = "localhost:80"

    #[[inputs.postgresql]]
      #$DBINPUT

    [[inputs.prometheus]]
      ## HTTP Basic Authentication username and password. ('bearer_token' and
      ## 'bearer_token_string' take priority)
      username = "indexdb"
      password = "indexdb"
      urls = $PULL_ENDPOINTS
      namepass = []
      namedrop = []

    # Send epoch time for each node
    [[inputs.exec]]
      commands = ["date +%s",]
      timeout='10s'
      name_override="time.epoch"
      data_format="value"
      data_type="long"
